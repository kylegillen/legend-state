import type { ObservableComputed, ObservableEvent, ObservableObject, ObservableReadable, ObservableWriteable, ObserveEvent, OpaqueObject, Selector, TypeAtPath } from './observableInterfaces';
export declare function isObservable(obs: any): obs is ObservableObject;
export declare function isEvent(obs: any): obs is ObservableEvent;
export declare function isComputed(obs: any): obs is ObservableComputed;
export declare function computeSelector<T>(selector: Selector<T>, e?: ObserveEvent<T>, retainObservable?: boolean): any;
export declare function getObservableIndex(obs: ObservableReadable): number;
export declare function opaqueObject<T extends object>(value: T): OpaqueObject<T>;
export declare function lockObservable(obs: ObservableReadable, value: boolean): void;
export declare function setAtPath<T extends object>(obj: T, path: string[], pathTypes: TypeAtPath[], value: any, fullObj?: T, restore?: (path: string[], value: any) => void): T;
export declare function setInObservableAtPath(obs: ObservableWriteable, path: string[], pathTypes: TypeAtPath[], value: any, mode: 'assign' | 'set'): void;
export declare function mergeIntoObservable<T extends ObservableObject | object>(target: T, ...sources: any[]): T;
export declare function constructObjectWithPath(path: string[], pathTypes: TypeAtPath[], value: any): object;
export declare function deconstructObjectWithPath(path: string[], pathTypes: TypeAtPath[], value: any): object;
export declare function isObservableValueReady(value: any): boolean;
export declare function setSilently(obs: ObservableReadable, newValue: any): any;
export declare function getPathType(value: any): TypeAtPath;
export declare function initializePathType(pathType: TypeAtPath): any;
export declare function safeStringify(value: any): string;
export declare function safeParse(value: any): any;
export declare function clone(value: any): any;
